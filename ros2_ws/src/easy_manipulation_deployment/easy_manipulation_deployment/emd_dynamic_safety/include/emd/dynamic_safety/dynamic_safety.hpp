// Copyright 2021 ROS Industrial Consortium Asia Pacific
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef EMD__DYNAMIC_SAFETY__DYNAMIC_SAFETY_HPP_
#define EMD__DYNAMIC_SAFETY__DYNAMIC_SAFETY_HPP_

#include <memory>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

#include "emd/utils.hpp"
#include "emd/dynamic_safety/safety_zone.hpp"
#include "emd/dynamic_safety/collision_checker.hpp"
// #include "emd/dynamic_safety/next_point_publisher.hpp"
#include "emd/dynamic_safety/replanner.hpp"
#include "emd/dynamic_safety/visualizer.hpp"
#include "emd/profiler.hpp"
#include "realtime_tools/realtime_buffer.h"

namespace dynamic_safety
{

struct Option
{
  double rate;

  bool dynamic_parameterization;

  bool use_description_server;

  std::string description_server;

  std::string joint_limits_parameter_server;
  std::string joint_limits_parameter_namespace;

  std::unordered_map<std::string, std::pair<double, double>> joint_limits;

  std::string robot_description;
  std::string robot_description_semantic;

  std::string environment_joint_states_topic;

  std::string moveit_scene_topic;

  bool allow_replan;

  bool benchmark;

  bool visualize;

  SafetyZone::Option safety_zone_options;

  CollisionCheckerOption collision_checker_options;

  // NextPointPublisher::Option next_point_publisher_options;

  ReplannerOption replanner_options;

  Visualizer::Option visualizer_options;

  const Option & load(const rclcpp::Node::SharedPtr & node);
};

class DynamicSafety
{
public:
  // cppcheck-suppress unknownMacro
  RCLCPP_SMART_PTR_DEFINITIONS(DynamicSafety)

  /// Constructor
  /**
   * Load options automatically from node parameters.
   *
   * Example:
   * ```yaml
   * dynamic_safety_node:
   *   ros__parameters:
   *     dynamic_safety:
   *       dynamic_parameterization: true
   *       use_description_server: true
   *       description_server: /rviz2
   *       environment_joint_states_topic: /joint_states
   *       joint_limits_parameter_server: /rviz2
   *       joint_limits_parameter_namespace: "robot_description_planning.joint_limits"
   *       allow_replan: true
   *       visualize: true
   *       look_ahead_time: 1.2

   *       rate: 100.0  # Optional

   *       collision_checker:
   *         # distance: false
   *         # continuous: false
   *         step: 0.01

   *       visualizer:
   *         publish_frequency: 10
   *         step: 0.1
   *         topic:  ur3e_dynamic_safety_markers
   *         tcp_link: ur3e_gripper_link

   *       replanner:
   *         framework: moveit
   *         planner: ompl
   *         ompl_planner_id: RRTConnect
   *         planner_parameter_server: /moveit_simple_controller_manager
   *         planner_parameter_namespace: ompl
   *         time_parameterization: totg
   *         group: manipulator1
   *         deadline: 0.5
   * ```
   * \param[in] node parameter loading node
   */
  explicit DynamicSafety(
    rclcpp::Node::SharedPtr node);

  /// Constructor
  /** loading options
   * Load configurations from options
   * \param[in] option configuration for dynamic safety
   */
  explicit DynamicSafety(const Option & option);

  /// Destructor
  virtual ~DynamicSafety();

  /// Configure the dynamic safety module
  /**
   * Load additional parameters from parameter server
   * Spawning thread configuration.
   * starting up publisher, timer, subscriber
   * \param[in] node
   */
  void configure(
    const rclcpp::Node::SharedPtr & node);

  /// Add a new trajectory to activate the dynamic safety node.
  /**
   * Various module would start pre-processing of the trajectory
   * during this activation stage.
   * \param[in] rt robot trajectory message
   */
  void add_trajectory(
    const trajectory_msgs::msg::JointTrajectory::SharedPtr & rt);

  /// Set external callback function when new trajectory is generated by replanning module
  /**
   * By default, the add_trajectory function from this class would be called instead.
   * \param[in] cb new trajectory callback function
   */
  void set_new_trajectory_callback(
    std::function<void(const trajectory_msgs::msg::JointTrajectory::SharedPtr &)> cb);

  /// Update current time
  /**
   * The time here is representing where robot is wrt to the start of the trajectory.
   * Scaling would be applied beforehand.
   * \param[in] current_time scaled time to update
   */
  void update_time(double current_time);

  /// Update state
  /**
   * This function can be called to update joint state from encoder.
   * \param[in] state joint state from encoder.
   */
  void update_state(const sensor_msgs::msg::JointState::SharedPtr & state);

  /// Update state
  /**
   * This function can be called to update joint state from encoder.
   * \param[in] joint_names joint name order for reference.
   * \param[in] current_state joint state from encoder.
   */
  void update_state(
    const std::vector<std::string> & joint_names,
    const trajectory_msgs::msg::JointTrajectoryPoint & current_state);

  /// Update state
  /**
   * This function can be called to update joint state from encoder.
   * \param[in] joint_names joint name order for reference.
   * \param[in] state joint state from encoder.
   */
  void update_state(
    const std::vector<std::string> & joint_names,
    const trajectory_msgs::msg::JointTrajectoryPoint::SharedPtr & state);

  /// Get execution scale
  /**
   * \return scale for execution
   */
  double get_scale();

  /// Start the dynamic safety module.
  void start();

  /// Wait for the trajectory to complete / stop is called.
  void wait();

  /// Stop, need to add trajectory again to restart.
  void stop();

  class Impl;

private:
  std::unique_ptr<Impl> impl_ptr_;
};

}  // namespace dynamic_safety


#endif  // EMD__DYNAMIC_SAFETY__DYNAMIC_SAFETY_HPP_
